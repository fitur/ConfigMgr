<#
.SYNOPSIS
    Scanna datorer enligt föreskrift.

.DESCRIPTION
    Detta skript används för att köra SCEP-uppgifter på begäran vid ärende.

.NOTES
    Version history:
    1.0.0 - (2018-09-18) Skript skapat.
    1.0.1 - (2019-02-11) Uppdaterat med variabelnamn för dynamiska variabler.

.NOTES
    FileName:    Invoke-MalwareScan.ps1
    Author:      Peter Olausson
    Contact:     peter.olausson@retune.se
    Created:     2018-09-18
    Updated:     2019-02-11
    Version:     1.0.1
#>
[CmdletBinding()]
param (
    # Desktop-konfiguration. Lägg till kundinformation i denna.
	[parameter(Mandatory = $false, HelpMessage = "Full path to configuration XML-file.")]
	[ValidateNotNullOrEmpty()]
	$Settings = "https://retunefile.blob.core.windows.net/desktopmgmt/konfiguration.xml",

    # Här sparas loggar.
    $LogsDirectory = (Join-Path -Path $env:SystemRoot -ChildPath "Temp"),

    # Namn på logg.
    $LogName = "MalwareScan.log",

    # Här sparas konfigurationsfilen.
    $UserSettingXML = (Join-Path -Path $env:TEMP -ChildPath "anv-konfiguration.xml"),

    [System.Collections.ArrayList]$ProcessedDevices = @()
)
Begin {
    # Functions
	function Write-CMLogEntry {
		param (
			[parameter(Mandatory = $true, HelpMessage = "Value added to the log file.")]
			[ValidateNotNullOrEmpty()]
			[string]$Value,
			[parameter(Mandatory = $true, HelpMessage = "Severity for the log entry. 1 for Informational, 2 for Warning and 3 for Error.")]
			[ValidateNotNullOrEmpty()]
			[ValidateSet("1", "2", "3")]
			[string]$Severity,
			[parameter(Mandatory = $false, HelpMessage = "Name of the log file that the entry will written to.")]
			[ValidateNotNullOrEmpty()]
			[string]$FileName = $LogName
		)
		# Determine log file location
		$LogFilePath = Join-Path -Path $LogsDirectory -ChildPath $FileName

		# Construct time stamp for log entry
		$Time = -join @((Get-Date -Format "HH:mm:ss.fff"), "+", (Get-WmiObject -Class Win32_TimeZone | Select-Object -ExpandProperty Bias))

		# Construct date for log entry
		$Date = (Get-Date -Format "MM-dd-yyyy")

		# Construct context for log entry
		$Context = $([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)

		# Construct final log entry
		$LogText = "<![LOG[$($Value)]LOG]!><time=""$($Time)"" date=""$($Date)"" component=""OSImageUpdateScheduler"" context=""$($Context)"" type=""$($Severity)"" thread=""$($PID)"" file="""">"

		# Add value to log file
		try {
			Add-Content -Value $LogText -LiteralPath $LogFilePath -ErrorAction Stop
		}
		catch [System.Exception] {
			Write-Warning -Message "Unable to append log entry to $($LogName) file. Error message: $($_.Exception.Message)"
		}
	}

    function Get-CustomerSettings {
        try {
            # Create local settings file if not exist
            if (!(Test-Path -Path $UserSettingXML)) {
                $FirstRun = $true
                $script:UserXML = New-Object -TypeName XML
                $UserXML.AppendChild($UserXML.CreateXmlDeclaration("1.0","UTF-8",$null))
                $UserXML.AppendChild($UserXML.CreateComment("Skapades $(Get-Date -Format "yyyy-MM-dd hh:mm"). Används med användarkonto $env:USERNAME"))
                $script:Node = $UserXML.CreateNode("element","Customers",$null)
                $UserXML.AppendChild($Node)
                $UserXML.Save($UserSettingXML)
            }
            else {
                $script:UserXML = New-Object -TypeName XML
                $UserXML.Load($UserSettingXML)
                $script:UserConfig = $UserXML.Customers.Customer
            }

            # Attempt to import settings XML
            $XML = New-Object -TypeName XML
            $XML.Load($Settings)
            $script:Customers = New-Object -TypeName System.Collections.ArrayList
            foreach ($item in $XML.Customers.Customer) {
                $temp = New-Object -TypeName PSCustomObject
                $temp | Add-Member -MemberType NoteProperty -Name "Name" -Value $item.Name
                $temp | Add-Member -MemberType NoteProperty -Name "Server" -Value $item.Server
                $temp | Add-Member -MemberType NoteProperty -Name "Domain" -Value $item.Domain
                $temp | Add-Member -MemberType NoteProperty -Name "SiteCode" -Value ""
                $temp | Add-Member -MemberType NoteProperty -Name "Credentials" -Value ""
                if ($FirstRun -eq $true) {
                    $temp | Add-Member -MemberType NoteProperty -Name "UserName" -Value ""
                } else {
                    $temp | Add-Member -MemberType NoteProperty -Name "UserName" -Value ($UserConfig | Where-Object {$_.Name -match $item.Name} | Select-Object -ExpandProperty Credentials)
                }
                $Customers.Add($temp) | Out-Null
            }
        }
        catch {
            Write-CMLogEntry -Value "Error loading customer specific settings. Message: $($_.Exception.Message)" -Severity 2
        }
    }

    function Invoke-Scan {
		param (
			[parameter(Mandatory = $true, HelpMessage = "datornamn.domain.local")]
			[ValidateNotNullOrEmpty()]
            [ValidatePattern("(?=^.{4,253}$)(^((?!-)[a-zA-Z0-9-]{0,62}[a-zA-Z0-9]\.)+[a-zA-Z]{2,63}$)")]
			[string]$Device
		)
        # Create temporary placeholder for customer data and scanned devices
        $TempCustomer = $Customers | Where-Object {$_.Domain -match $Device.Substring($Device.IndexOf(".")+1)}

        # Check if device already scanned
        if ( ($Device -in $ProcessedDevices.Device) -and ($ProcessedDevices | Where-Object { $_.Device -eq $Device } | Select-Object -ExpandProperty Date) -ge (Get-Date).AddHours(-1) ) {
            Write-CMLogEntry -Value "Client operation already sent to $Device within the last hour. Last scan was initiated at $($ProcessedDevices | Where-Object { $_.Device -eq $Device } | Select-Object -ExpandProperty Date)." -Severity 2
            Write-Host "$Device already scanned at $($ProcessedDevices | Where-Object { $_.Device -eq $Device } | Select-Object -ExpandProperty Date)" -BackgroundColor DarkRed -ForegroundColor White
        }
        else {
            # Add credentials & SiteCode if not exist
            if ($TempCustomer.Credentials -eq "") {
                $TempCustomer.Credentials = (Get-Credential -UserName (Join-Path -Path $TempCustomer.Domain -ChildPath ($TempCustomer.UserName | Split-Path -Leaf -ErrorAction SilentlyContinue)) -Message "Autentisera mot $($TempCustomer.Name)")
                try {
                    $TempCustomer.SiteCode = (Get-WmiObject -ComputerName $TempCustomer.Server -Namespace "root\SMS" -Class "SMS_ProviderLocation" -Credential $TempCustomer.Credentials | Select-Object -ExpandProperty SiteCode)

                    # Add temporary customer data to user configuration XML
                    if ($TempCustomer.Name -notin $UserXML.Customers.Customer.Name) {
                        ## Append user information to UserConfigXML
                        $TempElement = $UserXML.CreateElement("Customer")
                        $TempElement.SetAttribute("Name",$TempCustomer.Name)
                        $TempElement.SetAttribute("Credentials",$TempCustomer.Credentials.UserName)
                        $TempCustomer.UserName = $TempCustomer.Credentials.UserName # Add to itself
                        $Node.AppendChild($TempElement)

                        # Save user config XML
                        $UserXML.Save($UserSettingXML)

                        # Update user config array in script
                        $script:UserConfig = $UserXML.Customers.Customer
                    }
                }
                catch [System.Exception] {
                    Write-CMLogEntry -Value "Error loading $($TempCustomer.Name)-specific SiteCode variable. Message: $($_.Exception.Message)" -Severity 2
                }
            }

            # Run Client Operation
            try {
                $WmiSplat = @{
                    "ComputerName" = $TempCustomer.Server
                    "Namespace" = "root\SMS\site_$($TempCustomer.SiteCode)"
                    "Credential" = $TempCustomer.Credentials
                }
                $TempDevice = Get-WmiObject -Query "select ResourceID from SMS_R_System where Name = '$($Device.Substring(0,$Device.IndexOf($TempCustomer.Domain)-1))'" @WmiSplat

                # Run only if device ResourceID exist
                if ($TempDevice -notlike "") {
                    Invoke-WMIMethod -Class SMS_ClientOperation -Name "InitiateClientOperation" -ArgumentList @($null, "SMS00001", $TempDevice.ResourceId, 3) @WmiSplat | out-null
                    $COResult = Invoke-WMIMethod -Class SMS_ClientOperation -Name "InitiateClientOperation" -ArgumentList @($null, "SMS00001", $TempDevice.ResourceId, 1) @WmiSplat
                }
                else {
                    Write-CMLogEntry -Value "Could not get information for device $Device from SCCM." -Severity 2
                }

                # Write success to log if Operation result exist
                if ($COResult.OperationID -ne $null) {
                    $temp = New-Object -TypeName PSCustomObject
                    $temp | Add-Member -MemberType NoteProperty -Name "Device" -Value $Device
                    $temp | Add-Member -MemberType NoteProperty -Name "Date" -Value (Get-Date)
                    $ProcessedDevices.Add($temp) | Out-Null

                    Write-CMLogEntry -Value "Successfully initiated client operations on $Device" -Severity 1
                    Write-Host "$Device successfully scanned." -BackgroundColor DarkGreen -ForegroundColor White
                }
            }
            catch [System.Exception] {
                Write-CMLogEntry -Value "Error loading $($TempCustomer.Name)-specific SiteCode variable. Message: $($_.Exception.Message)" -Severity 2
            }
        }
    }
}
Process {
    # Get customer data
    Get-CustomerSettings

    # Loop
    do {
        Clear-Host
        $Input = Read-Host -Prompt "Device FQDN (computername.customer.local)"
        Invoke-Scan -Device $Input
        Wait-Event -Timeout 5
    } while ($Input -ne "Q")
}
